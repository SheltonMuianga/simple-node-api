"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.clientInputValidationDecorator = void 0;
var objectAssign_1 = require("../utils/lang/objectAssign");
var inputValidation_1 = require("../utils/inputValidation");
var lang_1 = require("../utils/lang");
var constants_1 = require("../utils/constants");
var utils_1 = require("../trackers/impressionObserver/utils");
/**
 * Decorator that validates the input before actually executing the client methods.
 * We should "guard" the client here, while not polluting the "real" implementation of those methods.
 */
function clientInputValidationDecorator(settings, client, readinessManager) {
    var log = settings.log;
    var isSync = (0, utils_1.isStorageSync)(settings);
    /**
     * Avoid repeating this validations code
     */
    function validateEvaluationParams(maybeKey, maybeFeatureFlagNameOrNames, maybeAttributes, methodName) {
        var multi = (0, lang_1.startsWith)(methodName, 'getTreatments');
        var key = (0, inputValidation_1.validateKey)(log, maybeKey, methodName);
        var splitOrSplits = multi ? (0, inputValidation_1.validateSplits)(log, maybeFeatureFlagNameOrNames, methodName) : (0, inputValidation_1.validateSplit)(log, maybeFeatureFlagNameOrNames, methodName);
        var attributes = (0, inputValidation_1.validateAttributes)(log, maybeAttributes, methodName);
        var isNotDestroyed = (0, inputValidation_1.validateIfNotDestroyed)(log, readinessManager, methodName);
        (0, inputValidation_1.validateIfOperational)(log, readinessManager, methodName);
        var valid = isNotDestroyed && key && splitOrSplits && attributes !== false;
        return {
            valid: valid,
            key: key,
            splitOrSplits: splitOrSplits,
            attributes: attributes
        };
    }
    function wrapResult(value) {
        return isSync ? value : Promise.resolve(value);
    }
    function getTreatment(maybeKey, maybeFeatureFlagName, maybeAttributes) {
        var params = validateEvaluationParams(maybeKey, maybeFeatureFlagName, maybeAttributes, 'getTreatment');
        if (params.valid) {
            return client.getTreatment(params.key, params.splitOrSplits, params.attributes);
        }
        else {
            return wrapResult(constants_1.CONTROL);
        }
    }
    function getTreatmentWithConfig(maybeKey, maybeFeatureFlagName, maybeAttributes) {
        var params = validateEvaluationParams(maybeKey, maybeFeatureFlagName, maybeAttributes, 'getTreatmentWithConfig');
        if (params.valid) {
            return client.getTreatmentWithConfig(params.key, params.splitOrSplits, params.attributes);
        }
        else {
            return wrapResult((0, objectAssign_1.objectAssign)({}, constants_1.CONTROL_WITH_CONFIG));
        }
    }
    function getTreatments(maybeKey, maybeFeatureFlagNames, maybeAttributes) {
        var params = validateEvaluationParams(maybeKey, maybeFeatureFlagNames, maybeAttributes, 'getTreatments');
        if (params.valid) {
            return client.getTreatments(params.key, params.splitOrSplits, params.attributes);
        }
        else {
            var res_1 = {};
            if (params.splitOrSplits)
                params.splitOrSplits.forEach(function (split) { return res_1[split] = constants_1.CONTROL; });
            return wrapResult(res_1);
        }
    }
    function getTreatmentsWithConfig(maybeKey, maybeFeatureFlagNames, maybeAttributes) {
        var params = validateEvaluationParams(maybeKey, maybeFeatureFlagNames, maybeAttributes, 'getTreatmentsWithConfig');
        if (params.valid) {
            return client.getTreatmentsWithConfig(params.key, params.splitOrSplits, params.attributes);
        }
        else {
            var res_2 = {};
            if (params.splitOrSplits)
                params.splitOrSplits.forEach(function (split) { return res_2[split] = (0, objectAssign_1.objectAssign)({}, constants_1.CONTROL_WITH_CONFIG); });
            return wrapResult(res_2);
        }
    }
    function track(maybeKey, maybeTT, maybeEvent, maybeEventValue, maybeProperties) {
        var key = (0, inputValidation_1.validateKey)(log, maybeKey, 'track');
        var tt = (0, inputValidation_1.validateTrafficType)(log, maybeTT, 'track');
        var event = (0, inputValidation_1.validateEvent)(log, maybeEvent, 'track');
        var eventValue = (0, inputValidation_1.validateEventValue)(log, maybeEventValue, 'track');
        var _a = (0, inputValidation_1.validateEventProperties)(log, maybeProperties, 'track'), properties = _a.properties, size = _a.size;
        var isNotDestroyed = (0, inputValidation_1.validateIfNotDestroyed)(log, readinessManager, 'track');
        if (isNotDestroyed && key && tt && event && eventValue !== false && properties !== false) { // @ts-expect-error
            return client.track(key, tt, event, eventValue, properties, size);
        }
        else {
            return isSync ? false : Promise.resolve(false);
        }
    }
    return {
        getTreatment: getTreatment,
        getTreatmentWithConfig: getTreatmentWithConfig,
        getTreatments: getTreatments,
        getTreatmentsWithConfig: getTreatmentsWithConfig,
        track: track
    };
}
exports.clientInputValidationDecorator = clientInputValidationDecorator;
